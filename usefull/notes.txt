Цель проекта - научиться разворачивать кластеры Cubernetes.
Итоговый кластер Cubernetes будет содержать в себе несколько контейнеров (один для каждого сервиса / процесса). Такое построение контейнеров является правильным.

Разворачивать множество контейнеров не оптимально и этим сложно управлять, поэтому начали появляться методы оркестрации (управления), когда несколько контейнеров работают вместе и существуют методы управления ими. 
В проекте мы будем разворачивать несколько сервисов, работающий каждый в своем контейнере и будем управлять ими средствами Cubernetes. 
Доступ к контейнерам (содержащим сервисы) осуществляется только через loadbalancer (в нашем случае Metallb, так как мы создает кластер на собственном железе - своем компьютере), не напрямую.

Есть 4 "группы" сервисов:
1. WP, MySQL, PHP. WP и PHP связаны через базу данных MySQL.
2. Nginx - одиночный сервис. Делает редиректы.
3. FTPS -  одиночный сервис. Обмен файлами на сервере.
4. Grafana, Influx, Telegraf. Grafana визуализирует готовые метрики в графики. Influx хранит в себе эти метрики. Telegraf эти метрики собирает, без него Influx работать не будет. 

Основные понятия Cubernetes:
- Pod (в нашем случае в нем только контейнер). Это может быт только процесс, процесс и база данных и тд. 
- Нода. Содержит в себе несколько подов и обслуживает их (поддерживает их работоспособность). Следит, чтобы они были в рабочем состоянии. Так же через специальный прокси следит, чтобы к контейнерам был предоставлен доступ.
- Кластер. Его образует несколько нод. В кластере есть мастер нода (содержит в себе инструменты управления Cubernetes) и слейв ноды. В нашем варианте будет одна нода, которая сама себе и мастер и слейв. В ней есть все элементы управления и собираются все контейнеры.

Инструменты управления контейнерами Cubernetes:
- Kubelet. Проверяет, что все контейнеры запущены и в порядке.
- Kube-proxy. Обеспечивает доступ к контейнерам, их связь между собой и внешним миром (посредством портов, он так же следит, чтобы порты были открыты). 
- DNS. Каждый под содержит номер, так же ему можно присвоить имя. DNS хранит связку номер пода - название, что позволяет получать нам доступ к подам по их названиям (в проекте название пода - это название сервиса, который на нем запущен).
- Dashboard (веб-интерфейс). Он встроен в Cubernetes, позволяет полностью управлять кластером: показывает состояние всех нод, подов, деплоев; позволяет запускать их, убивать, настраивать, заходить внутрь, смотреть логи.

Для работы над проектом нужно установить: minicube, virtualbox, docker. 

Запуск:
1. Миникуб в виртуальной машине: minikube start --vm-driver=vitrualbox
Так мы получаем готовую ноду, с которой уже можно работать. 
2. Переключить докер на работу внутри кластера: eval $(minikube docker-env)
Нужно делать каждый раз при работе в новом окне терминала
3. Билд образа с присвоением ему имени: docker build -t nginx_image . -f /dockerfile_directory/
4. Подключить металлб: minikube addons enable metallb
5. Применить настройки сервиса: kubectl apply -f configmap.yaml
6. Применить настройки пода: kubectl apply -f nginx.yaml

Просмотреть поды / деплои / сервисы:
	kubectl get pods
		      deploy
		      svc
Удалить под / деплой: 
	kubectl delete pods nginx
		       deploy nginx-deployment
Инфо о поде: 
	kubectl logs pods nginx
	kubectl describe pods nginx
Инфо об аддонах:
	minikube addons list
Выполнить команду в контейнере пода:
	kubectl exec
Открыть консоль контейнера:
	kubectl exec -ti $POD_NAME bash
Создать деплой:
	kubectl create deployment deployname
Протестировать работу ssh:
	ssh sadolph@$(minikube ip) -p 22
Скопировать файл из контейнера в выбранную директорию на компе
	docker cp mysql:/etc/mysql .
Удалить ненужные образы
	docker rmi $(docker images --filter "dangling=true" -q --no-trunc)

Сгенерировать sh-ключ хоста: ssh-keygen -A

Мы пытались открыть порт 80 в поде и привязать его к сервайсу лоадбэлэнсер по порту 80. Для этого мы поставили металлб, применили к нему конфигмап, создали сервайс. 
Металлб подхватывает сервайс

В каждой ноде Kubernetes как минимум работает:
- Kubelet — процесс, отвечающий за взаимодействие между мастером Kubernetes и узлом; он управляет подами и запущенными контейнерами на рабочей машине.
- Среда выполнения контейнера (в нашем случае, Docker), отвечающая за получение (загрузку) образа контейнера из реестра, распаковку контейнера и запуск приложения.

mysql:
создать юзера и подгрузить заготовленную заранее базу ()
